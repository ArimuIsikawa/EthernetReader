<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Карта + live image</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
<style>
  html, body { height:95%; margin:0; padding:0; font-family: Arial, sans-serif; }
  .topbar { padding:8px; background:#f2f2f2; border-bottom:1px solid #ddd; display:flex; gap:8px; align-items:center; }
  .btn { padding:8px 10px; border-radius:6px; border:1px solid #bbb; background:#fff; cursor:pointer; }
  .container { display:flex; height: calc(100% - 56px); gap:12px; padding:12px; box-sizing:border-box; }
  .left { flex:1 1 0; display:flex; flex-direction:column; min-width:300px; }
  .right { width:660px; /* 640 + padding/border */ display:flex; flex-direction:column; align-items:center; }
  .map-box { flex:1; min-height:200px; border:1px solid #ddd; border-radius:8px; overflow:hidden; }
  #map { width:100%; height:100%; }
  .routes { display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; }
  .route-slot { display:flex; flex-direction:column; gap:6px; padding:6px; border:1px solid #ddd; border-radius:6px; min-width:140px; background:#fff; }
  .color-dot { width:16px; height:16px; border-radius:4px; border:1px solid rgba(0,0,0,0.12); display:inline-block; margin-right:6px; vertical-align:middle; }
  .info { margin-left:auto; font-size:13px; color:#222; padding-right:6px; }
  /* image panel */
  .image-panel { width:640px; height:480px; border:1px solid #ccc; border-radius:8px; background:#111; display:flex; align-items:center; justify-content:center; overflow:hidden; }
  .image-panel img { max-width:100%; max-height:100%; display:block; }
  .image-meta { margin-top:8px; font-size:13px; color:#333; width:100%; display:flex; justify-content:space-between; }
  .udp-status { font-size:13px; padding:6px 8px; border-radius:6px; border:1px solid #ddd; background:#fff; }
  .udp-status.ok { border-color:#2a9d8f; color:#0a6; }
  .udp-status.none { color:#999; }
  .marker-number { display:inline-block; color:#fff; border-radius:50%; width:24px; height:24px; line-height:24px; text-align:center; border:2px solid white; box-shadow:0 0 0 1px rgba(0,0,0,0.15); font-weight:700; }
  @media (max-width:1100px){
    .container{ flex-direction:column; }
    .right{ width:100%; }
    .image-panel{ width:100%; height:320px; }
  }
  .leaflet-attribution-flag { display: none !important; }
</style>
</head>
<body>
<div class="topbar">
  <button id="sendBtn" class="btn">Отправить</button>
  <button id="clearBtn" class="btn">Очистить</button>

  <div class="routes" id="routes"></div>

  <div class="info">Маркер(ов): <span id="count">0</span></div>

  <div style="margin-left:12px;">
    <span>Координаты: <strong id="udp-port">14558</strong></span>
    <span id="udp-status" class="udp-status none">Нет данных</span>
    <label style="margin-left:8px;"><input type="checkbox" id="udp-enable" checked/> live</label>
    <span style="margin-left:12px;">Изображение: <strong id="img-port">15419</strong></span>
  </div>
</div>

<div class="container">
  <div class="left">
    <div class="map-box"><div id="map"></div></div>
    <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
    </div>
  </div>

  <div class="right">
    <div class="image-panel" id="image-panel">
      <div id="loading">Ожидаем изображение по TCP...</div>
      <img id="theimage" src="" style="display:none" />
    </div>
  </div>
</div>

<script>
(function(){
  const routeColors = ["#e34a4a", "#2a9d8f", "#f4a261"];

  // Map setup
  const map = L.map('map', { zoomControl:true }).setView([55.753215, 37.622504], 5);
  L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', { attribution: '&copy; CARTO', maxZoom:19 }).addTo(map);

  // Markers (numbered)
  let markers = [];
  function refreshCount(){ document.getElementById("count").textContent = markers.length; }
  function createNumberedMarker(latlng, number, color) {
    const html = '<div class="marker-number" style="background:' + color + ';">' + String(number) + '</div>';
    const icon = L.divIcon({ className:'', html: html, iconSize:[24,24], iconAnchor:[12,12] });
    const m = L.marker(latlng, { icon: icon, riseOnHover:true }).addTo(map);
    m.on('contextmenu', ()=>{ removeMarkerObject(m); });
    return m;
  }
  function renumberAll(){ for(let i=0;i<markers.length;i++){ const item=markers[i]; const html='<div class="marker-number" style="background:'+item.color+';">'+String(i+1)+'</div>'; item.marker.setIcon(L.divIcon({className:'', html:html, iconSize:[24,24], iconAnchor:[12,12]})); } refreshCount(); }
  function addMarkerAt(latlng,color){ const number=markers.length+1; const col=color||routeColors[0]; const m=createNumberedMarker(latlng,number,col); markers.push({marker:m, lat:latlng.lat, lon:latlng.lng, color:col}); refreshCount(); }
  function removeMarkerObject(lmarker){ let idx=-1; for(let i=0;i<markers.length;i++){ if(markers[i].marker===lmarker){ idx=i; break; } } if(idx>=0){ map.removeLayer(markers[idx].marker); markers.splice(idx,1); renumberAll(); } }
  map.on('click', function(e){ addMarkerAt(e.latlng, routeColors[0]); });
  document.getElementById("clearBtn").addEventListener("click", ()=>{ markers.forEach(it=>{ try{ map.removeLayer(it.marker);}catch{} }); markers=[]; refreshCount(); });

  // Routes UI
  const routesContainer = document.getElementById("routes");
  function makeSlotElement(slot, color) {
    const wrap = document.createElement('div');
    wrap.className = 'route-slot';
    wrap.id = 'route-slot-' + slot;
    const colorDotHtml = '<span class="color-dot" style="background:' + color + ';"></span>';
    wrap.innerHTML = `
      <div style="font-weight:700">${colorDotHtml} Маршрут ${slot}</div>
      <div style="display:flex; gap:6px;">
        <button data-act="save" data-slot="${slot}" class="btn">Сохранить</button>
        <button data-act="load" data-slot="${slot}" class="btn">Загрузить</button>
        <button data-act="del"  data-slot="${slot}" class="btn">Очистить</button>
      </div>
      <div class="meta" id="route-meta-${slot}">—</div>
    `;
    wrap.querySelector('[data-act="save"]').addEventListener('click', () => saveRouteSlot(slot));
    wrap.querySelector('[data-act="load"]').addEventListener('click', () => loadRouteSlot(slot));
    wrap.querySelector('[data-act="del"]').addEventListener('click', () => deleteRouteSlot(slot));
    return wrap;
  }
  for (let s=1;s<=3;s++){
    routesContainer.appendChild(makeSlotElement(s, routeColors[s-1]));
  }

  async function saveRouteSlot(slot) {
    const pts = markers.map(it => ({ lat: Number(it.lat.toFixed(7)), lon: Number(it.lon.toFixed(7)) }));
    const color = routeColors[slot-1] || routeColors[0];
    try {
      const resp = await fetch('/route/save?slot=' + slot, {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({ points: pts, color: color })
      });
      if (!resp.ok) throw new Error("Server " + resp.status);
      alert("Сохранён маршрут " + slot + ".");
      fetchRouteMetaAndUpdateUI();
    } catch (e) { alert("Ошибка сохранения: " + e); }
  }

  async function loadRouteSlot(slot) {
    try {
      const resp = await fetch('/route/load?slot=' + slot);
      if (resp.status === 404) { alert("Маршрут " + slot + " пуст."); return; }
      if (!resp.ok) throw new Error("Server " + resp.status);
      const data = await resp.json();
      // clear and render
      markers.forEach(it=>{ try{ map.removeLayer(it.marker);}catch{} }); markers=[];
      const pts = data.points || [];
      const color = data.color || routeColors[slot-1];
      for (let p of pts){ addMarkerAt({lat: p.lat, lng: p.lon}, color); }
      alert("Загружен маршрут " + slot);
    } catch (e) { alert("Ошибка загрузки: " + e); }
  }

  async function deleteRouteSlot(slot) {
    if (!confirm("Удалить маршрут в слоте " + slot + "?")) return;
    try {
      const resp = await fetch('/route/delete?slot=' + slot, { method: 'POST' });
      if (!resp.ok) throw new Error("Server " + resp.status);
      alert("Очищен маршрут " + slot + ".");
      fetchRouteMetaAndUpdateUI();
    } catch (e) { alert("Ошибка очистки: " + e); }
  }

  async function fetchRouteMetaAndUpdateUI(){
    try {
      const resp = await fetch('/route/meta');
      if (!resp.ok) return;
      const meta = await resp.json();
      for (let s=1;s<=3;s++){
        const el = document.getElementById('route-meta-' + s);
        const n = meta[String(s)] || 0;
        el.textContent = n > 0 ? ("Точек: " + n) : "Пусто";
      }
    } catch (e) { console.warn("Failed to fetch route meta:", e); }
  }
  fetchRouteMetaAndUpdateUI();

  // Send -> server writes coords.txt
  document.getElementById("sendBtn").addEventListener("click", async function(){
    const pts = markers.map(it => ({ lat: Number(it.lat.toFixed(7)), lon: Number(it.lon.toFixed(7)) }));
    const payload = { points: pts, provider: "carto_voyager", ts: (new Date()).toISOString() };
    try {
      const resp = await fetch('/send', {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify(payload)
      });
      if (!resp.ok) throw new Error("Server returned " + resp.status);
      alert("Отправлено: " + pts.length + " точек.");
      fetchRouteMetaAndUpdateUI();
    } catch (err) {
      alert("Ошибка отправки: " + err);
    }
  });

  let udpMarker = null;
  let udpLastTs = null;
  const udpPortLabel = document.getElementById("udp-port");
  udpPortLabel.textContent = "14558";
  const udpStatusEl = document.getElementById("udp-status");
  const udpEnableCheckbox = document.getElementById("udp-enable");

  async function pollUdpLast(){
    if (!udpEnableCheckbox.checked) {
      udpStatusEl.className = "udp-status none";
      udpStatusEl.textContent = "Пауза";
      return;
    }
    try {
      const resp = await fetch('/udp/last');
      if (resp.status === 204) {
        udpStatusEl.className = "udp-status none";
        udpStatusEl.textContent = "Нет данных";
        return;
      }
      if (!resp.ok) throw new Error("Server " + resp.status);
      const data = await resp.json(); // {lat,lon,ts,raw,from}
      if (typeof data.lat === 'undefined' || typeof data.lon === 'undefined') {
        udpStatusEl.className = "udp-status none";
        udpStatusEl.textContent = "Некорректные данные";
        return;
      }
      udpStatusEl.className = "udp-status ok";
      udpStatusEl.textContent = "•live•";
      if (udpLastTs !== data.ts || !udpMarker) {
        udpLastTs = data.ts;
        const latlng = [data.lat, data.lon];
        if (!udpMarker) {
          udpMarker = L.circleMarker(latlng, { radius:8, fillColor: '#1f77b4', color:'#fff', weight:2, fillOpacity:1 }).addTo(map);
          udpMarker.bindTooltip("БВС", {permanent:true, direction:'right'}).openTooltip();
        } else {
          udpMarker.setLatLng(latlng);
        }
      }
    } catch (e) {
      udpStatusEl.className = "udp-status none";
      udpStatusEl.textContent = "UDP poll err";
    }
  }

  setInterval(pollUdpLast, 500);
  pollUdpLast();

  // --- Image: SSE + fetch to show in right panel ---
  const imgEl = document.getElementById("theimage");
  const loading = document.getElementById("loading");
  const imgInfo = document.getElementById("img-info");
  const imgTs = document.getElementById("img-ts");
  const imgPortLabel = document.getElementById("img-port");
  imgPortLabel.textContent = "15419";

  async function fetchAndShowImage() {
    try {
      const resp = await fetch('/image-live?ts=' + Date.now());
      if (resp.status === 204) {
        imgEl.style.display = "none";
        loading.style.display = "";
        imgInfo.textContent = "Нет изображений";
        imgTs.textContent = "";
        return;
      }
      if (!resp.ok) throw new Error("HTTP " + resp.status);
      const blob = await resp.blob();
      if (imgEl._objUrl) {
        URL.revokeObjectURL(imgEl._objUrl);
      }
      const url = URL.createObjectURL(blob);
      imgEl._objUrl = url;
      imgEl.src = url;
      imgEl.style.display = "";
      loading.style.display = "none";
      // fetch meta for ts (we can fetch /image-meta or use SSE data)
      // We'll just request /image-meta or parse header? Simpler: call /image/last (not implemented) - instead show timestamp from SSE event (set in handler)
    } catch (e) {
      console.warn("Failed to fetch image:", e);
    }
  }

  // SSE: listen for new-image events and update meta
  try {
    const es = new EventSource('/image/stream');
    es.addEventListener('new-image', function(ev) {
      // ev.data contains timestamp
      const ts = ev.data || "";
      fetchAndShowImage();
    });
    es.onmessage = function(ev) {
      fetchAndShowImage();
    };
    es.onerror = function() {
      console.warn("SSE connection error for image stream");
    };
    es.onopen = function() {
      // try initial fetch
      fetchAndShowImage();
    };
  } catch (e) {
    // fallback polling
    setInterval(fetchAndShowImage, 3000);
    fetchAndShowImage();
  }

  // ensure map resizes correctly on load
  setTimeout(()=>{ try{ map.invalidateSize(); }catch(e){} }, 300);
})();
</script>
</body>
</html>
